type Client {
	id: ID
	name: String
	lastname: String
	email: String
	phones: [ String ]
	address: String
	about: String
    twitter_id: ID
    facebook_id: ID
    organization: Organization
    interventions: [ Intervention ]
    devices: [ Device ]
    #Tickets soliticatos por el client
    tickets: [ Ticket ]
}
enum AgentRole {
    AGENT
    SUPERVISOR
    ADMIN
    ADMIN_ACCOUNT
}

type Agent {
	id: ID
    role: AgentRole
    name: String
    lastname: String
    email: String
    phones: [ String ]
    about: String
    profession: String
    supplier: Supplier
    #Tickets asignados actualmente al agente
    tickets: [ Ticket ]
}

type Organization {
    id: ID
    name: String
    about: String
    domains: [ String ]
    clients: [ Client ]
    #Tickets creados por clientes de esta organizacion
    tickets: [ Ticket ]
}

type Supplier {
    id: ID
    name: String
    about: String
    agents: [ Agent ]
    #Tickets asignados actualmente al proveedor
    tickets: [ Ticket ]
}

type Device {
	id: ID
	code: String
	name: String
	client: Client
	tickets: [ Ticket ]
}

type Task {
	text: String
	done: Boolean
}

type Group {
    id: ID
    name: String
    about: String
    group_scale: Group
    agents: [ Agent ]
    #Agentes que deben ser notificados
    notification_agents: [ Agent ]
    #Tiempo en que deben ser notificados los agentes cuando un ticket no ha sido asignado
    notification_hours: Int
    notification_text: String
    #Tickets asignados actualmente al grupo
    tickets: [ Ticket ]
}

type Message {
	text: String
	time: String
	agent: Agent
}

type Discussion {
	id: ID
    ticket: Ticket
	agents: [ Agent ]
	messages(last: Int): [ Message ]
}

union Autor = Client | Agent

enum InterventionAutor {
	AGENT
	CLIENT
}

type Intervention {
	id: ID
	text: String
	time: String
	type_autor: InterventionAutor
	autor: Autor
	ticket: Ticket
}

enum Source {
	PORTAL
	EMAIL
	FACEBOOK
	TWITTER
}

type TicketType {
    key: String
    text: String
}

enum TicketPriority {
    low
    medium
    high
    urgent
}

type Ticket {
    id: ID
    time: String
    number: Int
    title: String
    description: String
    #Las prioridades como enum ya que no son modificables
    priority: TicketPriority
    type: TicketType
    state: Status
    #Estados a los que puede ir el ticket (calculado)
    next_states: [ Status ]
    source: Source
    agente: Agent
    client: Client
    activities: [ Activity ]
    intervention: [ Intervention ]
    discussion: Discussion
    device: Device
    group: Group
    supplier: Supplier
    tasks: [ Task ]
    custom_fields: [ TicketField ]
    #Cuando debe o debio realizarse la primera respuesta segun el SLA
    response_by: String
    #Cuando debe o debio solucionarse el ticket segun el SLA
    resolve_by: String
    #Sera null en los tickets que no esten solucionados (1-5, no satisfecho- satisfecho)
    satisfaction_level: Int
}

type TicketField {
	value: FieldValue
	metadata: Field
}

union FieldValue = TextValue | NumberValue | SelectValue | CheckValue

type TextValue {
	text: String
}

type NumberValue {
	number: Int
}

type SelectValue {
	key: String
}

type CheckValue {
	check: Boolean
}


enum FieldType {
	TEXT
	TEXTAREA
	NUMBER
	DATE
	SELECT
	CHECKBOX
}

union Field = FreeField | SelectField

type FreeField {
	position: Int
	key: String
	label: String
	type: FieldType
}

type SelectOption {
	text: String
	key: String
	position: Int
}

type SelectField {
	position: Int
	key: String
	label: String
	type: FieldType
	options: [ SelectOption ]
}

enum ActivityAutor {
	AGENT
	CLIENT
	SYSTEM
}

type Activity {
	id: ID
	time: String
	ticket: Ticket
	type_autor: ActivityAutor
	autor: Autor
	changes: [ Change ]
}

type Change {
	prop_name: String
	old_value: String
	new_value: String
}

type Stage {
	id: ID
	key: String
	name: String
	statuses: [ Status ]
}

enum UserRole {
	AGENT
	SUPPLIER
    CLIENT
}

type Status {
	id: ID
	key: String
	label: String
	stage: Stage
	# Estados a los que se puede ir hacia ese estado
    came_from: [ Status ]
}

type Category {
	id: ID
	name: String
	articles: [ Article ]
}

type Article {
    id: ID
	name: String
	description: String
	time: String
	publisher_user: Agent
}

union Entity = Agent | Client | Supplier

type User {
	entity: Entity
    rol: UserRole
	notifications: [ Notification ]
}

type Notification {
	text: String
	time: String
	readed: Boolean
	ticket: Ticket

}

enum UnityTime {
	MINUTES
	HOURS
	DAYS
	MONTHS
}

enum OperationalHours {
	CALENDAR
	BUSINESS
}

type PolicyTime {
	value: Int
	unity: UnityTime
}

type Policy {
    priority: TicketPriority
    first_response: PolicyTime
    solved: PolicyTime
    #Si el tiempo correra en horas habiles o 24x7
    operational_hours: OperationalHours
}

type SLAPolicy {
    id: ID
    default: Boolean
    name: String
    description: String
    active: Boolean
    position: Int
    #Una politica para cada prioridad
    policies: [ Policy ]
    clients: [ Client ]
    organizations: [ Organization ]
    alerts: [ Alert ]
}

type Alert {
	# Puede ser recordatorio o violación del SLA
	type: AlertType
	# Puede ser respuesta o resolución
	motive: AlertMotive
	hours: Float
	to: [ Agent ]
	message: String
}

enum AlertType {
	REMINDER
	SLA_VIOLATION
}

enum AlertMotive {
	RESPONSE
	RESOLUTION
}

type Horary {
    #Hora del dia en que se comienza a trabajar
    start: Int
    #Hora del dia en que se termina de trabajar
    end: Int
}

enum WeekDay {
	MONDAY
	TUESDAY
	WEDNESDAY
	THURSDAY
	FRIDAY
	SATURDAY
	SUNDAY
}

type Holiday {
	name: String
	day: Int
	month: Int
}

type WorkingDay {
	day: WeekDay
	horary: Horary
}

type BusinessHours {
	working_days: [ WorkingDay ]
	holidays: [ Holiday ]
}

enum AutomationsType {
	DISPATCHER
	OBSERVER
	SUPERVISOR
	SCENARIO
}

union Automation = Dispatcher | Observer | Supervisor | Scenario

type Condition {
	#Campo que está siendo condicionado
	conditioned_field: Field
	# Operador de la condición
	condition_operator: ConditionOperator
	# Valor con el que va a ser comparado
	value: FieldValue
}

type SupervisorCondition {
	#Campo que está siendo condicionado
	conditioned_param: TimeConditions
	# Operador de la condición
	condition_operator: ConditionOperator
	# Valor con el que va a ser comparado
	hours: Int
}

enum ConditionOperator {
	IS
	NOT
	CONTAINS
	NOT_CONTAINS
	STARTS
	ENDS
	TRUE
	FALSE
	HIGHER
	HIGHER_OR_EQUAL
	LESS
	LESS_OR_EQUAL
}

enum TimeConditions {
	HOURS_SINCE_CREATED
	HOURS_SINCE_PENDING
	HOURS_SINCE_RESOLVED
	HOURS_SINCE_ASSIGNED
	HOURS_SINCE_REQUESTER_RESPONDED
	HOURS_SINCE_AGENT_RESPONDED
	HOURS_SINCE_TICKET_OVERDUE
}

enum LogicalComparator {
	AND
	OR
}

type Dispatcher {
	id: ID
	name: String
	description: String
	comparator: LogicalComparator
	conditions: [ Condition ]
	actions: [ Action ]
}

type Supervisor {
	id: ID
	name: String
	description: String
	comparator: LogicalComparator
	conditions: [ Condition ]
	time_conditions: [ SupervisorCondition ]
	actions: [ Action ]
}

type Observer {
	id: ID
	name: String
	description: String
	autors: [ Agent ]
	# En caso de que sea cualquiera, no habrá array de agentes
	anyone: Boolean
	events: [ Event ]
	comparator: LogicalComparator
	conditions: [ Condition ]
	actions: [ Action ]
}

type Scenario {
	id: ID
	name: String
	description: String
	comparator: LogicalComparator
	conditions: [ Condition ]
	actions: [ Action ]
}

# Los eventos se podrán configurar para cuando cambie cualquier campo del ticket
type Event {
	id: ID
	observer: Observer
	field: Field
	# Teniendo el campo podré saber si los valores que tengo son id, keys o texto, fecha, lo que sea,
	# y podré acceder a ellos fácilmente, aunque quizá no sea necesario
	old_value: FieldValue
	new_value: FieldValue
}

union Action = ActionField | ActionEmail

type ActionField {
	field: Field
	# El valor puede tener múltiples tipos de dato, pero con string se puede parsear fácilmente
	new_value: FieldValue
}

union EmailReceiver = Agent | Client | Group

type ActionEmail {
	subject: String
	body: String
	to: EmailReceiver
	receiver_type: ReceiverType
}

enum ReceiverType {
	AGENT
	CLIENT
	GROUP
}

type Tenant {
	id: ID
	name: String
	subdomain: String
	phones: [ String ]
	active: Boolean
	subscription_time: String
	# Imagen en base64
	icon: String
	colors: TenantColors
	plans: [ TenantPlan ]
}

type TenantColors {
	primary: String
	secundary: String
	tertiary: String
	quaternary: String
}

type TenantPlan {
	subscription_plan: SubscriptionPlan
	# plan_key: String
	start_date: String
	end_date: String
	annual_payment: Boolean 
	# Calculado con dia actual y fecha_fin	
	active: Boolean
}

type SubscriptionPlan {
	id: ID
	name: String 
	slogan: String
	# Precio en dólares del mes, pagando de contado el año
	monthly_cash_price: Int
	# Precios del mes, pagando mensual
	monthly_credit_price: Int
	multiple_SLA: Boolean
	satisfaction_survey: Boolean
	ticket_custom_fields: Boolean
	dispatcher: Boolean
	observer: Boolean
	supervisor: Boolean
	scenario: Boolean
	knowledge_base: Boolean
	multichannel_support: Boolean
}

type Indicators {
	unresolved: Int
	overdue: Int
	due_today: Int
	open: Int
	on_hold: Int
	unassigned: Int
}

type Query {
    clients: [ Client ]
	client(id: ID!): Client
    #EL ticket_id es opcional. Si no se provee, se obtiene para todos los clientes
    devices(cliente_id: ID): [ Device ]
    organizations: [ Organization ]
    organization(id: ID!): Organization

    agents: [ Agent ]
    agent(id: ID!): Agent
    groups: [ Group ]
    group(id: ID): Group
    suppliers: [ Supplier ]
    supplier(id: ID!): Supplier

    ticket(id: ID!): Ticket
    tickets: [ Ticket ]
    #EL ticket_id es opcional. Si no se provee, se obtiene para todos los tickets
    activities(ticket_id: ID, last: Int): [ Activity ]
    #EL ticket_id es opcional. Si no se provee, se obtiene para todos los tickets
    interventions(ticket_id: ID, last: Int): [ Intervention ]

    solutions: [ Category ]
    solution(id: ID!): Category
    article(id: ID!): Article

    notifications(last: Int): [ Notification ]

    discussion(ticket_id: ID!): Discussion

    businessHours: BusinessHours
    SLAPolicies: [ SLAPolicy ]

    indicators: Indicators
}

type Mutation {
    createClient(client: client): Client
    updateClient(client: client): Client
    createDevice(client_id: ID!): Device
    createOrganization(organization: organization): Organization
    updateOrganization(organization: organization): Organization

    createAgent(agent: agent): Agent
    updateAgent(agent: agent): Agent
    createGroup(group: group): Group
    updateGroup(group: group): Group
    disolveGroup(group_id: ID): String
    createSupplier(supplier: supplier): Supplier
    updateSupplier(supplier: supplier): Supplier

    createTicket(ticket: ticket): Ticket
    addIntervention(ticket_id: ID): Intervention
    updateTicket(ticket: ticketUpdate): Ticket

    createCategory(category: category): Category
    updateCategory(category: category): Category
    addArticle(article: article): Article
    updateArticle(article: article): Article

    addAgentsToDiscussion(agents_id: [String], ticket_id: ID): [ Agent ]

    updateBusinessHours(business_hours: businessHours): BusinessHours
    createSLAPolicy(slapolicy: slapolicy): SLAPolicy
    updateSLAPolicy(slapolicy: slapolicy): SLAPolicy
}

type Subscription {
	notifications: Notification
	new_discussion: Discussion
	discussion_message(ticket_id: ID!): Message
	activities(ticket_id: ID): Activity
	interventions(ticket_id: ID): Intervention
}

schema {
	query: Query
    mutation: Mutation
    subscription: Subscription
}